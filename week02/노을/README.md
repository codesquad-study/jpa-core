# 2장. JPA 시작



#### 엔티티 매니저

- JPA의 기능 대부분은 엔티티 매니저가 제공 한다.

- 엔티티를 데이터베이스에 등록/수정/삭제/조회 할 수 있다.
- 객체를 저장하는 가상의 데이터베이스 처럼 보임.



#### 트랜잭션 관리

- JPA를 사용하면 항상 트랜잭션 안에서 데이터를 변경해야 한다.



#### JPQL(Java Persistence Query Language)

- 엔티티 객체를 대상으로 쿼리
  - 클래스와 필드를 대상으로 쿼리
- 데이터베이스 테이블을 전혀 알지 못한다.
- SQL과 다르게 대소문자를 명확하게 구분한다.



# 3장. 영속성 관리



#### 엔티티 매니저 팩토리 

- 스레드가 동시에 접근해도 안전

#### 엔티티 매니저 

- 동시성 문제가 발생하므로, 스레드 간에 절대 공유 X

- 데이터베이스 연결이 꼭 필요한 시점까지 커텍션을 얻지 않는다.

#### 영속성 컨텍스트(Persistence Context)

- 엔티티를 영구 저장하는 환경
- 엔티티 매니저는 `영속성 컨텍스트`에 엔티티를 보관하고 관리

- `persist()` 메소드는 엔티티 매니저를 사용해서 회원 엔티티를 `영속성 컨텍스트`에 저장
- 앤티티 매니저를 통해서만 접근할 수 있음
- `애플리케이션`과 `데이터베이스` 사이에서 객체를 보관하는 `가상의 데이터베이스 `역할

#### 엔티티 생명주기

- 비영속, 영속, 준영속, 삭제
  - `영속 상태`는 `식별자 값`이 반드시 있어야 한다.



#### 영속성 컨텍스트와 데이터베이스 저장

- 플러시 : 트랜잭션을 커밋하는 순간 `영속성 컨텍스트`에 있는 저장된 엔티티를 데이터베이스에 반영



#### 영속성 컨텍스트가 엔티티를 관리하면 장점

- 1차 캐시,  동일성 보장,  쓰기 지연,  변경 감지,  지연 로딩



# 4장. 엔티티 매핑



- JPA를 사용하는데 가장 중요한 일은 엔티티와 테이블을 정확히 매핑하는 것



#### @Entity  적용 시 주의 사항

- 기본 생성자 필수
- final 클래스, enum, interface, inner 클래스에 사용 불가



- 제인 발표자료 스크랩
  - ![image-20210907201530164](../../../../Downloads/images/image-20210907201530164.png)



#### 기본 키 맵핑

- 직접 할당 

  - 엔티티 필드에 `@Id`만 사용

- 자동 생성 (대리키)

  - `다양한 이유`: DB 벤더마다 지원하는 방식이 다르기 때문임.

    - IDENTITY
    - SEQUENCE
    - TABLE
      - 키 생성용 테이블 하나 만들어두고 마치 시퀀스처럼 사용하는 방법
      - 모든 데이터베이스에서 사용 가능

    

#### IDENTITY 전략과 최적화

- MySQL, PostgreSQL, DB2, SQL Server 데이터베이스에서 사용
- 데이터베이스에 엔티티를 `저장`해서 식별자 값을 획득한 후 영속성 컨텍스트에 `저장`

- IDENTITY 전략은 데이터를 데이터베이스에 INSERT한 후에 `기본 키` 값을 조회
  - 엔티티에 식별자 값을 할당하려면 JPA는 데이터베이스 추가 조회 필요
    - 대안: JDBC3의 `Statement.getGeneratedKeys()`
      - 데이터를 저장하면서 동시에 생성된 기본 키 값도 얻어올 수 있음.
- 주의
  - 엔티티가 `영속 상태`가 되려면 식별자가 반드시 필요
  - 데이터베이스에 저장해야 식별자를 구할 수 있으므로 `em.persist()`를 호출하는 즉시 INSERT SQL이 DB에 전달
  - 즉, `트랜잭션을 지원하는 쓰기 지연`이 동작하지 않음.



#### SEQUENCE 전략

- 데이터베이스 시퀀스에서 식별자 값을 획득한 후 영속성 컨텍스트에 저장

- 137p, 138p 질문



#### TABLE 전략

- 데이터베이스 시퀀스 생성용 테이블에서 식별자 값을 획득한 후 영속성 컨텍스트에 저장



#### AUTO 전략

- 데이터베이스 방언에 따라 IDENTITY, SEQUENCE, TABLE 전략 중 하나를 `자동`으로 선택
- `@GenereatedValue.strategy` 의 기본값은 `AUTO`
- 장점: 데이터베이스를 변경해도 코드를 수정할 필요가 없음.



#### 권장하는 식별자 선택 전략

- 자연 키보다는 대리키 권장
  - 현실과 비즈니스 규칙은 생각보다 쉽게 변한다.
    - ex) 주민등록번호를 자연키로 사용중, 정부 정책 변경으로 주민등록번호를 저장할 수 없을  경우



# 5장. 연관관계 매핑 기초



- 객체는 `참조`를 사용해서 관계를 맺고, 테이블은 `외래키`를 사용해서 관계를 맺는다.
- 방향은 객체관계에만 존재하고, 테이블 관계는 항상 양방향

-  참조를 통한 연관관계는 언제나 단방향
  - 양쪽에 참조 필드를 둬서, 양방향 처럼 만들 순 있지만 정확히는 `서로 다른 단방향 관계 2개`



- `객체 그래프 탐색`: 객체는 참조를 사용해서 연관관계를 탐색

- `@JoinColumn(name ="TEAM_ID")` 

  - 조인 컬럼은 외래 키를 매핑할 때 사용
  - 생략할 경우
    - 기본 전략: `필드명 + _ + 참조하는 테이블의 컬럼명`
      - ex) team_TEAM_ID 외래키를 사용

- #### 조회

  - 연관관계가 있는 엔티티를 조회하는 방법 2가지

    - `객체 그래프 탐색`

    - `객체지향 쿼리 사용 JPQL`

      

- #### 양방향 관계

  - 서로 다른 단뱡향 연관관계 2개를 묶은 것
  - `연관관계 주인` 
    - 두 객체 연관관계 중 하나를 정해서 테이블의 `외래키`를 관리 해야함
    - 테이블에 외래키가 있는 곳을 주인으로 설정
    - 주인만이 외래키의 값을 변경할 수 있음.
  - `mappedBy` 속성
    - 주인이 아님을 설정
    - `mappedBy=필드명`
    - 읽기만 가능하고, 외래키를 변경하지는 못한다.

- #### 연관관계 편의 메소드

  - 각각 호출하다 보면 실수로 둘 중 하나만 호출해서 양방향이 깨질 수 있음.
  - 한 번에 양방향 관계를 설정하는 메소드