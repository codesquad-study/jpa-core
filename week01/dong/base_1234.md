## DB와 OOP간의 패러다임의 차이 - JPA가 필요한 이유 빌드업

### 상속
- OOP 이론에서는 객체간 상속의 개념이 있지만
- RDB이론에서는 상속의 개념이 없음
  - 비슷한게 있다면 RDB의 슈퍼타입과 서브쿼리가 있긴 함
  - 예외적으로 RDB중 포스트그리QL에는 테이블상속이 있긴 함
    - https://corekms.tistory.com/entry/table-inheritance%EC%83%81%EC%86%8D
    - https://postgresql.kr/docs/9.2/tutorial-inheritance.html
    - https://postgresql.kr/

#### JPA는 OOP패러다임에 DB를 끼워맞추는걸 쉽게 할수 있도록 지원하는 API인데
- DB를 날것그대로 접근하면(JDBC Template) 이런저런 문제가 많으니
- DB를 한겹 더 추상화시켜서 JCF처럼 사용해서 데이터를 자바 패러다임에 맞춰서 CURD하는게 바로 JPA의 컨셉
  - 그런데 앞에서도 말한것처럼 RDB패러다임-OOP패러다임간 불일치 때문에, 위의 원대하고 아름다운 목표를 달성하는게 쉽지않음
  - 그래서 자바개발자가 공통적으로 사용할수있는 DB 접근용 API가 나온거다

### 연관관계
- 연관관계에서도 차이가 있는데
  - OOP에서는 객체간에는 오직 단방향 관계만이 존재한다
  - RDB에서는 테이블간에 양방향 관계가 가능하다
- 문제가 발생하게 되는 순서
  - 연관관계의 차이점으로 인한 한계때문에 조회시 문제가 발생하고
  - 엔티티를 신뢰할수 없는 문제로 나타나는데
  - 계층분할이 어렵다. 즉 DB계층의 사용자와 DB개발자(DBA)간에 역할구분이 어렵다
  - 컬렉션(자바 OOP)  와  DB간에 GET이 다르다. 달라도 너무 다르다!

### JPA가 필요한 이유 (이 단락의 결론)
- 객체지향적으로 자바기반의 프로젝트를 구성할수록
  - DB접근하고 맵핑하기에는 일이 너무 많아진다.
  - DB 개발할게 너무 많아져서 결국은 자바프로젝트로 시작했는데 SQL프로젝트 개발자가 된 모습을 목격할수 있다
- 한마디로 ROI가 너무 구려진다 (Return On Investment의 약자 ,투자대비 이익률)
  - 투자한 시간에 비해 아웃풋이 안나오게 되므로 뭘 해야한다??




## JPA를 소개합니다
- JPA는 자바에서 사용하는 ORM입니다
  - ORM은 OOP패러다임과 RDB 패러다임 사이의 간극을 매꿔주는 (어떤것/ 프레임워크? / 라이브러리?)
- OOP패러다임과 RDB 패러다임 사이의 간극/불일치를 해결해 줍니다

### (8분 지점)왜 JPA를 써야하냐면
- JPA의 개발사상은 DB Access Like As JCF 이기 때문에
- 신뢰성 있는 엔티티 계층
  - (는는비교 ==) 동일성을 보장해줍니다
- JPA가 제공하는 성능최적화를 사용할수 있습니다
  - 1차캐시에서 동일성을 보장하고 쿼리문이 나가는 횟수를 최소로 줄여줍니다
  - 버퍼링(캐싱) 기능이 있어 모아쓰기가 지원됩니다 (커밋을 알아서 최소한으로 해서 Disk I/O횟수를 줄이도록 JPA단에서 노력한다)
    - 결국 개발자는  Disk I/O횟수같은거 신경쓰지말고 로직개발에 더 집중할 수 있게 된다
  - 레이지로딩 기능도 있음(에거 로딩 쓰지말기 리마인드!)




## 엔티티매니저팩토리 와 엔티티매니저

-   영속성컨텍스트 
- db에다가 저장하는게 아니다!
- 영속성 컨텍스트에 저장하는거다!

## 영속성 컨텍스트란?

- 논리적인 개념
- 이걸 왜 써야하냐 이점이 뭔가?
  - App과 DB 사이에 Buffer가 있어서 : cache 기능을 수행
  - 없는것보다 성능이 좋은게, APP과 DB사이는 직렬화된 통신(네트워크)로 데이터를 주고받는다
- 영속성 컨텍스트의 장점 다섯가지
  - 1차캐시, 동일성(identity)보장, 트랜잭션을 지원하는 쓰기지연(transactional w-behiend), 변경감지(dirty check), 지연로딩(Lazy Loading)

### 1차 캐시가 있다
- Map자료구조의 1차 캐시가 존재한다
  - key : id
  - value : 엔티티객체
- 이로인한 장점으로는 조회시 (em.find)
  - 1차캐시부터 탐색한다! DB에 먼저 접근하지 않는다
  - 없으면 DB에서 탐색한다
- 반환시에
  - 1차캐시에 저장하면서 반환도 동시에 한다
  - find를 연속해서 여러번 사용해도 쿼리는 한번만 나간다
- 결론
  - 1차캐시는 DB의 한 트랜잭션에서만 동작하고
  - 복잡한 비지니스 로직에서 이점이 있다
  - 다이나믹하지는 않다
  - 성능상의 이점은 크지 않다
  - 컨셉에 이점이 있는데, 영속 엔티티간의 동일성을 보장한다
    - 같은 엔티티를 조회했다면, 식별자는 같고 객체는 완전동일하다(==비교시 true)
- EntitiyManager(em) 의 단위는 트랜잭션의 단위와 동일(혹은 생명주기)
- 참고로 JPA전체공유 캐시는 2차캐시



## 엔티티 등록시
- commit이 지연되고 Flush되는 시점은 알수없다


### 엔티티매니져 주의사항
- 엔티티 매니져 팩토리는 하나만 생성해서 애플리케이션 전체에서 공유
- 엔티티 매니져는 쓰레드간 공유하면 절대 안됨!!(사용하고 바로바로 버려야 한다)
- JP A의 모든 데이터 변경은 트랜잭션 안에서 실행

- 우리가 트랜잭션을 안걸어도 디비는 내부적으로 다 처리한다
  - 내가 모르고 보이지 않는다고 해서 하위 컴포넌트를 꼭 모를필요는 없다..??




## JPQL
- jpa쓰면 엔티티객체를 중심으로 개발(더이상 sql 아님!)
- 커밋함수를 호출하는 시점에 쿼리가 날라간다


## 엔티티의 생명주기
- 다섯단계로 구분
  - 비영속 : JPA와 관련이 없는 새로운 데이터가 만들어진 상태
  - 영속 : 영속상태, Persiste하다! 사실은 DB에는 저장이 안되어있는 상태
  - 준영속
  - 삭제 : detach `goodbye tars`


### DB에 엔티티가 저장되는 시점은 언제인가?
- before detach, after persiste
- 커밋하는 시점에 쿼리가 날라간다

## JPA의 목표
- JPA 의 궁극적인 지향점은 JCF(컬렉션프레임워크)처럼 Java를 다루는것이다
```java
Map <Long,Member> members;
Member jack = new Memeber("jack", 11);
members.add(1L,jack);
jack.setAge(77);

Member member = members.get(1L);
sout(jack.getAge()); // 77이 출력
```
- JCF의 특성 : 변경하고 다시 저장하지 않아도 자동으로 저장됨
- JPA도 이와 동일하다


## 더티체킹
- 변경감지, 엔티티 수정
- 영속성컨텍스트로 더티체킹이 가능함
- 변경사항이 있다면 커밋하는 시점에 반영됨
- 따로 persist() 안해줘도 커밋만 하는 시점에 반영된다! JCF랑 유사.. (힙영역에 엔티티가 살아있어!)

## Flush
- Flush란 DB에다가 컨텍스트의 내용을 반영하는 동작
- Flush발생시 -> 변경점체크(변경감시,더티체킹)
- 쓰기지연 SQL 등록
- SQL 쿼리로 DB에 전송
- 플러쉬 하는법 두가지 : en.fl / JQPL
- Flush 하자마자 1차캐시에도 안날라감
  - 먼저 쓰기지연 SQL에 반영되고
  - 변경잠지후
  - 날라감
- DB의 트랜잭션 플러쉬에 밀접
  - 데이터베이스도 나름의 시스템이랑 복잡한게 있지만
  - 파일시스템에 쓰기 기능을 수행한다 DISK IO가 발생하는 시점
  - 플러쉬 이후에 전기가 차단되도 데이터가 남아있음을 보장하는 함수
- 동시성과 동기화 이슈는 DB에 모든걸 전적으로 위임


## 쿼리는 언제 출발하니

- 코드

```java
System.out.println("== before");

em.persist(member);

System.out.println("== after");

tx.commit();
```

- 로그

```
== before
== after
09:43:32.546 [main] DEBUG org.hibernate.internal.util.EntityPrinter - hellojpa.Member{name=sector, id=199}
09:43:32.549 [main] DEBUG org.hibernate.SQL - 
    /* insert hellojpa.Member
        */ insert 
        into
            Member
            (name, id) 
        values
            (?, ?)
Hibernate: 
    /* insert hellojpa.Member
        */ insert 
        into
            Member
            (name, id) 
        values
            (?, ?)
```
- 쿼리는 커밋하는 시점에 나간다 
  - em.persist() 시점에 나가는게 아니다
- 두번 조회해도 쿼리는 한번만 나간다 : 왜냐하면 1차캐시에 있거든


## 더티체킹의 원리(JPA가 엔티티의 변경을 감지해서 커밋시점에 DB에게 쿼리문을 날려주는 일련의 과정)
- 최초상태(1차캐시에 들어올때) snap샷을 찍음, 이때는 당연히 DB와 동일하다
  - 왜냐면 영속상태로 들어오는 방법은 두가지뿐인데
    - find() 로 찾아오거나
    - commit 을 통해 디비가 동기화되어있는 시점이라
- 스냅샷을 보관하다가 다음 커밋 명령이 내려오는 시점에
- 내부적으로 flush를 호출해서 DB와 동기화하고
- Flush수행중에 snapshot과 비교해 변경점을 체크하는데
  - 변경점이 없다면 그대로 넘어가거
  - 변경점이 있다면 쓰기지연SQL로 넘어간다
- 쓰기지연 SQL에 모여있다가 DB로 쿼리문이 나가게 되어있다
### 더티체킹으로 인해 persist() 를 호출해야 하는가 하지않아도 되는건가?
- 호출하지 않는게 정답
- 엔티티 값만 바꾸는게 정답임
- 값을 바꾸면 자동으로 커밋시점에 알아서 바뀌기도 하고
- 심적 안정을 위해 persist() 호출한다고 해서 바뀌는건 아무것도 없기때문

## 플러쉬란?
- 영속성 컨텍스트 변경내용이 DB에 반영되는 동작
- 영속성 컨텍스트를 플러쉬 하는 3가지 방법
  - 직접호출 : em.flush()
  - 커밋호출 : 커밋하면 내부적으로 플러쉬가 호출된다
  - JPQL 쿼리 사용하기전에 왜 Flush를 때리냐면
    - JPQL에서 어떤 쿼리문이 들어올지 모르므로, 데이터 무결성을 보장하기 위해서 플러쉬를 때림!
### 플러쉬 특징 정리
- EntitiyContext(E-ctx)를 비우지 않음
- E-ctx와 DB 동기화 되는 시점을 의미
- 동기화, 동시성 관련 정책이나 이슈는 DB제품에 전적으로 위임
- 트랜잭션이라는 작업단위로 E-ctx와 같이 움직이며, 커밋직전에만 DB와 동기화

### 준영속상태(detach)
- 영속상태가 더이상 아닌상태(영속 >> 준영속), 3가지 방법으로 준영속 상태로 진입
  - detach : 이 하나만 지워
  - clear : 통째로 다지워
  - 
